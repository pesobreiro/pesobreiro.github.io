<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html><head><title>Optimizing Client/Server Performance</title>
<link REL="STYLESHEET" HREF="naetugp.css" TYPE="text/css">
<script Language="VBScript">
Dim look
Sub SyncURL(look)
if right(top.frames(0).frames(1).location.href, 10)="toc_tc.htm" then
top.frames(0).frames(1).TreeCtl1.SyncToURL(look)
end if
End Sub
</script>
<meta name="Microsoft Theme" content="expeditn 011, default"></head>
<!--DocHeaderStart-->
<body background="../../../../_themes/expeditn/exptextb.jpg" bgcolor="#FFFFFF" text="#000000" link="#993300" vlink="#666600" alink="#CC3300"><!--mstheme--><font face="book antiqua, times new roman, times"><a HREF="ba19_5.htm" OnClick="SyncURL(&quot;chapters/ba19_5.htm&quot;)"><img SRC="..\images\prevpage.gif" ALT="Previous Page" ALIGN="RIGHT" BORDER="0"></a>
<!--DocHeaderEnd-->
<!-- This is a PANDA Generated HTML file. The source is a WinWord Document. -->
<a NAME="3OptimizingClientServerPerformance"></a>
<p CLASS="heading3OrgHeading1h1">Optimizing Client/Server Performance</p>
<p CLASS="Textttext">In addition to functional differences between local and remote tables, there are often considerable performance differences. Some parts of your application that perform well with local data may be significantly slower when the data is on a server, and may cause too much network traffic or use excessive server resources. This section discusses techniques you can use to improve the performance of client/server applications.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For information on optimizing any application, see Chapter 13, <a HREF="../chapters/ba13_1.htm" OnClick="SyncURL(&quot;chapters/ba13_1.htm&quot;)">&quot;Optimizing Your Application.&quot;</a></p>
<a NAME="4SpeedingUpQueries"></a>
<p CLASS="heading4OrgHeading2h2">Speeding Up Queries</p>
<p CLASS="Textttext">The best way to improve the performance of queries on remote data is to have the server run as much of the query as possible. Microsoft Access attempts to send the entire query to the server, but evaluates locally any query clauses and expressions that aren't supported by servers in general or by your server in particular. Some information about server capability is available when you link a remote table.
<p CLASS="Textttext">If a query contains expressions that can't be evaluated by your server, more or less of the query is evaluated locally, depending on where the expressions occur. Queries with such expressions in the SELECT clause are still evaluated on the server, unless they occur in a totals query, a union query, or a query that uses the DISTINCT predicate, in which case they are evaluated locally. Such expressions in other clauses (for example, WHERE, ORDER BY, and GROUP BY clauses) cause at least part of the query to be evaluated locally.
<p CLASS="Textttext">This section describes how to design queries that maximize the use of the server and thereby improve query performance.</p>
<a NAME="5UsingSupportedFunctionality"></a>
<p CLASS="heading5OrgHeading3h3">Using Supported Functionality</p>
<p CLASS="Textttext">If possible, don't design queries that use functionality not generally supported by servers. The following sections identify some areas of functionality that aren't generally supported and others that usually are.</p>
<a NAME="6FunctionalityNotSupportedbyMostServers"></a>
<p CLASS="heading6OrgHeading4h4">Functionality Not Supported by Most Servers</p>
<p CLASS="Textttext">Most servers don't support:</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspOperations that can't be expressed in a single SQL statement<img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">for example, when a query's FROM clause contains a totals query or a query that uses the DISTINCT predicate. Often, you can rearrange your queries so that they calculate totals or apply the DISTINCT predicate after all other operations.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspOperations that are Microsoft Access-specific extensions to SQL, such as complex crosstab queries, queries that use the TOP predicate or the <span CLASS="ElementNameeln">TopValues</span> property, and reports that have multiple levels of grouping and totals.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspExpressions that contain operators or functions specific to Microsoft Access. For example, the Microsoft Access financial and domain aggregate functions have no server equivalents.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspUser-defined functions in Visual Basic that take remote fields as arguments. These functions don't exist on the server, but must process remote field data.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspHeterogeneous joins between local tables and remote tables, or between remote tables in different ODBC data sources.</p>
<p CLASS="ListText1lt1"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span><span CLASS="Xref">For more information, see <a HREF="#5HeterogeneousJoins" OnClick="SyncURL(&quot;chapters/ba19_6.htm&quot;)">&quot;Heterogeneous Joins&quot;</a> later in this section.</span></p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspExpressions or union queries that mix text and numeric data types. Most servers lack the data type leniency of Microsoft Access. If you need to mix data types, use explicit conversion functions.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For a list of DAO objects and methods that aren't supported for use with external data sources that don't use Microsoft Jet, see <a HREF="../chapters/ba18_2.htm#4UnsupportedObjectsandMethods" OnClick="SyncURL(&quot;chapters/ba18_2.htm&quot;)">&quot;Unsupported Objects and Methods&quot;</a> in Chapter 18, &quot;Accessing External Data.&quot;</p>
<a NAME="6FunctionalitySupportedbySomeServers"></a>
<p CLASS="heading6OrgHeading4h4">Functionality Supported by Some Servers</p>
<p CLASS="Textttext">Servers differ in certain areas of functionality. Some servers support:</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspOuter joins. (Note that Microsoft Access doesn't send multiple outer joins to a server, although many inner joins can accompany a single outer join.)</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspNumeric, string, and date/time functions (such as the <span CLASS="ElementNameeln">Log</span>, <span CLASS="ElementNameeln">Mid$</span>, and <span CLASS="ElementNameeln">DatePart</span> functions).</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspConversion functions (such as the <span CLASS="ElementNameeln">CInt</span>, <span CLASS="ElementNameeln">CStr</span>, and <span CLASS="ElementNameeln">CVDate</span> functions).</p>
<p CLASS="Textttext">If the operation is supported, it's sent to the server for processing; otherwise, it's performed locally.</p>
<a NAME="5SplittingWHEREClauseRestrictions"></a>
<p CLASS="heading5OrgHeading3h3">Splitting WHERE Clause Restrictions</p>
<p CLASS="Textttext">If a query's SQL statement includes a WHERE clause that the server can't evaluate completely, Microsoft Access splits the clause into several parts (linked by the AND operator), and sends as many of these parts to the server as possible. For example, suppose you write a function in Visual Basic called ProcessData and run the following query:</p>
<p CLASS="CodeTextct">SELECT field1, field2, field3<br>&nbsp;&nbsp;&amp;nbspFROM table1<br>&nbsp;&nbsp;&amp;nbspWHERE (field1 = 100 OR field1 = 200)<br>&nbsp;&nbsp;&amp;nbspAND ProcessData(field2) &gt; 100<br>&nbsp;&nbsp;&amp;nbspAND field3 LIKE &quot;A*&quot;</p>
<p CLASS="Textttext">Microsoft Access sends the following query to the server and evaluates <span CLASS="CodeTextEmbeddedcte">ProcessData(field2) &gt; 100</span> locally on the records returned.</p>
<p CLASS="CodeTextct">SELECT field1, field2, field3<br>&nbsp;&nbsp;&amp;nbspFROM table1<br>&nbsp;&nbsp;&amp;nbspWHERE (field1 = 100 OR field1 = 200)<br>&nbsp;&nbsp;&amp;nbspAND field3 LIKE &quot;A*&quot;</p>
<p CLASS="Textttext">If you need to use a WHERE clause restriction that your server can't process, you can limit the amount of data Microsoft Access requests by providing additional restrictions that your server can process. For maximum efficiency, these restrictions should involve fields indexed on the server.</p>
<a NAME="5OptimizingExpressionsThatContainMicrosoftAccessSpecificElements"></a>
<p CLASS="heading5OrgHeading3h3">Optimizing Expressions That Contain Microsoft Access-Specific Elements</p>
<p CLASS="Textttext">If expressions in your queries contain user-defined functions, domain aggregate functions, and other elements specific to Microsoft Access (such as the <span CLASS="ElementNameeln">IIf</span> and <span CLASS="ElementNameeln">Choose</span> functions), they can't be completely run by a server. If an expression that uses one of these elements involves remote data fields, Microsoft Access runs it locally and retrieves all necessary data from the server. If such an expression involves only constants and query parameters, however, Microsoft Access evaluates it just once and sends the result to the server as a query parameter.
<p CLASS="Textttext">Whenever possible, optimize your queries by avoiding references to remote fields in expressions that can't be evaluated by the server. For example, suppose you have a remote Tasks table with a Status field that contains code numbers (1 means unfinished and 2 means complete). The following query requires a user to type <span CLASS="ElementNameeln">1</span> or <span CLASS="ElementNameeln">2</span>, which isn't very intuitive.</p>
<p CLASS="CodeTextct">SELECT * FROM Tasks<br>&nbsp;&nbsp;&amp;nbspWHERE Status = [What Status?]</p>
<p CLASS="Textttext">In contrast, the following query allows the user to type <span CLASS="ElementNameeln">Unfinished</span> or <span CLASS="ElementNameeln">Complete</span> when prompted.</p>
<p CLASS="CodeTextct">SELECT * FROM Tasks<br>&nbsp;&nbsp;&amp;nbspWHERE [What Status?] = IIf(Status=1,'Unfinished','Complete')</p>
<p CLASS="Textttext">However, because the <span CLASS="ElementNameeln">IIf</span> function uses the remote Status field, Microsoft Access sends the first part of the statement <span CLASS="CodeTextEmbeddedcte">(SELECT * FROM Tasks)</span> to the server and evaluates the restriction on each record locally.
<p CLASS="Textttext">The following query also allows the user to type words instead of numbers.</p>
<p CLASS="CodeTextct">SELECT * FROM Tasks<br>&nbsp;&nbsp;&amp;nbspWHERE Status = IIf([What Status?]='Unfinished',1,2)</p>
<p CLASS="Textttext">However, because the return value of the <span CLASS="ElementNameeln">IIf</span> function is effectively constant, Microsoft Access evaluates it once locally and sends the following statement to the server, supplying this part of the expression as a parameter value.</p>
<p CLASS="CodeTextct">SELECT * FROM Tasks<br>&nbsp;&nbsp;&amp;nbspWHERE Status = ?</p>
<p CLASS="Textttext">This method is more efficient and reduces network traffic.</p>
<a NAME="5HeterogeneousJoins"></a>
<p CLASS="heading5OrgHeading3h3">Heterogeneous Joins</p>
<p CLASS="Textttext">To perform a <span CLASS="NewTermntrm">heterogeneous join</span><img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">a join between local and remote tables<img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">Microsoft Access either:</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspRequests all the records in the remote table or tables and performs the join locally.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspPerforms a <span CLASS="NewTermntrm">remote index join</span>. This means that for each key in the local table, Microsoft Access asks the server only for the records with a matching key value.</p>
<p CLASS="Textttext">Microsoft Access uses a remote index join only if the remote field being joined is indexed and if the local table is considerably smaller than the remote table. For example, to join a local table called Employees that contains 10 records and a remote table called Tasks that contains 50 records on the EmployeeID field, Microsoft Access retrieves the 50 records from the Tasks table on the server and processes the join locally. However, if the remote table contains 1,000 records, Microsoft Access performs a remote index join. It sends 10 of the following queries to the server, supplying each EmployeeID value from the local Employees table as a parameter value.</p>
<p CLASS="CodeTextct">SELECT EmployeeID, TaskID<br>&nbsp;&nbsp;&amp;nbspFROM Tasks<br>&nbsp;&nbsp;&amp;nbspWHERE EmployeeID = ?</p>
<p CLASS="Textttext">This is generally much faster than retrieving all 1,000 records.
<p CLASS="Textttext">Always index the remote join field so that Microsoft Access can perform a remote index join when appropriate. Regardless of whether or not Microsoft Access can perform a remote index join, you can improve the performance of a query that uses a heterogeneous join by supplying additional restrictions on remote fields. Microsoft Access sends these restrictions to the server, limiting the amount of data requested for the join.</p>
<a NAME="4SpeedingUpForms"></a>
<p CLASS="heading4OrgHeading2h2">Speeding Up Forms</p>
<p CLASS="Textttext">When you design a form based primarily on server data, take a minimalist approach for the best performance. Determine what data and functionality you need, and design forms that delay asking for this data and functionality until requested by the user. This section presents several minimalist techniques for improving the performance of your forms.</p>
<a NAME="5RequestingLessData"></a>
<p CLASS="heading5OrgHeading3h3">Requesting Less Data</p>
<p CLASS="Textttext">The more data you request from the server, the more processing time you use and the more network traffic you create. To request less data in your forms:</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspRequest as few records as necessary. For example, rather than opening a large <span CLASS="ElementNameeln">Recordset</span> object and navigating with one of the Find methods, use a filter or query to limit the size of the <span CLASS="ElementNameeln">Recordset</span>, being careful to use restrictions that the server can process.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspBase your forms on queries that select as few remote fields as necessary. That way, only fields used on the form are actually retrieved from the server. If you need to add fields to the form later, you can use the Query Builder (available from the <span CLASS="ElementNameeln">RecordSource</span> property box in the property sheet for the form).</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspUse fewer bound controls, such as text boxes, list boxes, and combo boxes. Each form control that is bound to a remote field requires a separate query to be sent to the server when the form is opened. In particular, avoid controls that contain totals, and list boxes and combo boxes with large row sources for the list.</p>
<a NAME="5DisplayingFieldsOnlyonRequest"></a>
<p CLASS="heading5OrgHeading3h3">Displaying Fields Only on Request</p>
<p CLASS="Textttext">In some cases, you may want a form to display all the fields in a record. In other cases, you may not need to make all the fields available to the user. To speed up the processing of your forms, you can use the following techniques to avoiding retrieving unnecessary data:</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspDisplay the most important fields on a main form and provide a button to open another form that contains the other fields. Base the second form on a query that uses the primary key value on the main form as criteria. For example, suppose you have a main form based on the following query:</p>
<p CLASS="ListCodeText1lct1">SELECT OrderID, CustomerID, OrderDate, ShipVia, ShippedDate<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspFROM Orders</p>
<p CLASS="ListText1lt1">You could base the second form on the following query, which runs only when the user clicks a button to request more information:
<p CLASS="ListText1lt1"></p>
<p CLASS="ListCodeText1lct1">SELECT Orders.*, Customers.*, Employees.*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspFROM (Orders INNER JOIN Customers<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspON Orders.CustomerID = Customers.CustomerID)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspINNER JOIN Employees<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspON Orders.EmployeeID = Employees.EmployeeID<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspWHERE OrderID = Forms!Orders!OrderID
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspDisplay Memo and OLE Object fields on a form only when the user requests to see the information. Because Microsoft Access doesn't retrieve Memo and OLE Object fields until they are displayed on the screen, waiting to display this data until it is needed improves performance. You can place Memo and OLE Object fields off screen on another form page. Add a label to the form, such as &quot;Scroll down to see notes and pictures,&quot; that tells the user how to display the information.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspSet the <span CLASS="ElementNameeln">Visible</span> property to No for controls bound to Memo and OLE Object fields, and add a toggle button or command button that sets the property to Yes when the user wants to view the contents of these controls.</p>
<a NAME="5DownloadingDataYouUseinMoreThanOneForm"></a>
<p CLASS="heading5OrgHeading3h3">Downloading Data You Use in More Than One Form</p>
<p CLASS="Textttext">Often, an application contains several forms that use the same remote table<img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">for example, as the source for a list box or combo box. If the data in the table doesn't change frequently, you can speed up form loading and reduce server load by using one of the following techniques:</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspIf the data in the table never changes (such as the names and abbreviations of states or regions), store the table in the local Microsoft Access database. If the table is joined in queries with remote tables, also keep a copy of it on the server to avoid heterogeneous joins.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspIf the data in the table changes rarely (such as a list of the buildings that a company owns), store the table both on the server and in the local Microsoft Access database. Your application must provide a way for the user to download the current data when it changes.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspIf the data in the table changes occasionally (that is, less than daily, such as the employees in a small company or department), store the table both on the server and in the local Microsoft Access database. When your application starts, it must check to see if the tables are out of sync and download the current data from the server. This method uses extra time when your application starts, but your queries run faster.</p>
<p CLASS="Textttext">In the following example, the LclDepts and LclEmps tables are local versions of the linked server tables RmtDepts and RmtEmps. The example empties the LclDepts and LclEmps tables and then repopulates them with the contents of the tables on the server.</p>
<p CLASS="CodeTextct">Dim wrkRemote As Workspace, dbsRemote As Database<br>Set wrkRemote = DBEngine.Workspaces(0)<br>Set dbsRemote = wrkRemote.Databases(0)<br>wrkRemote.BeginTrans<br>&nbsp;&nbsp;&amp;nbspWith dbsRemote<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute &quot;DELETE FROM LclDepts&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute &quot;INSERT INTO LclDepts SELECT * FROM RmtDepts&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute &quot;DELETE FROM LclEmps&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute &quot;INSERT INTO LclEmps SELECT * FROM RmtEmps&quot;<br>&nbsp;&nbsp;&amp;nbspEnd With<br>wrkRemote.CommitTrans</p>
<p CLASS="Textttext">This example uses the <span CLASS="ElementNameeln">BeginTrans</span> and <span CLASS="ElementNameeln">CommitTrans</span> methods to make the downloading operation a transaction. This delays writing any data to disk until the <span CLASS="ElementNameeln">CommitTrans</span> method runs.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For more information on using transactions, see <a HREF="#4UsingTransactions" OnClick="SyncURL(&quot;chapters/ba19_6.htm&quot;)">&quot;Using Transactions&quot;</a> later in this chapter.</p>
<a NAME="5UsingLessFunctionality"></a>
<p CLASS="heading5OrgHeading3h3">Using Less Functionality</p>
<p CLASS="Textttext">To improve the performance of your client/server application, you may want to avoid using some of the more powerful features of Microsoft Access. This section discusses when you can improve performance by using less functionality in your forms.</p>
<a NAME="6SnapshotsvsDynasets"></a>
<p CLASS="heading6OrgHeading4h4">Snapshots vs. Dynasets</p>
<p CLASS="Textttext">Microsoft Access provides two types of <span CLASS="ElementNameeln">Recordset</span> objects on which you can base your forms: dynasets, which can be updated, and snapshots, which cannot. If you don't need to update data with your form, and the <span CLASS="ElementNameeln">Recordset</span> contains fewer than 500 records, you can reduce the time it takes the form to open by setting the form's <span CLASS="ElementNameeln">RecordsetType</span> property to Snapshot. This causes Microsoft Access to use a snapshot-type <span CLASS="ElementNameeln">Recordset</span> object as the record source for the form, which is generally faster than using a dynaset.</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>If you're opening a snapshot in Visual Basic and need to make only one pass through the results, you can make the snapshot even more efficient by using the <span CLASS="ElementNameeln">dbForwardOnly</span> constant of the <span CLASS="ElementNameeln">OpenRecordset</span> method. This constant opens a forward-only-type <span CLASS="ElementNameeln">Recordset</span> object. For more information on forward-only-type <span CLASS="ElementNameeln">Recordset</span> objects, see Chapter 9, <a HREF="../chapters/ba09_1.htm" OnClick="SyncURL(&quot;chapters/ba09_1.htm&quot;)">&quot;Working with Records and Fields.&quot;</a></p>
<p CLASS="Textttext">However, if the <span CLASS="ElementNameeln">Recordset</span> you're using is large, or if it contains Memo or OLE Object fields, using a dynaset is more efficient. If you use a dynaset, Microsoft Access retrieves only the primary key of each record; if you use a snapshot, it retrieves the entire record. A dynaset is also more efficient because Memo and OLE Object fields are retrieved only if they are displayed on the screen or directly referenced in your code.</p>
<a NAME="6MultipleTableQueriesvsSubforms"></a>
<p CLASS="heading6OrgHeading4h4">Multiple-Table Queries vs. Subforms</p>
<p CLASS="Textttext">Two methods are available for displaying information from multiple tables in a form: you can either base the form on a query that joins the tables, or you can place one or more subforms on the form. The first approach usually sends a single query to the server, which creates the join. The second approach sends at least two queries: one to retrieve the data for the main form and one for each embedded subform. This second approach requires more time for the form to load as well as more overhead.
<p CLASS="Textttext">Because you can update and insert data in almost every field of a multiple-table query, a subform is often unnecessary. If you don't need the convenient display capabilities of a subform, base your form on a single query for better performance.</p>
<a NAME="4ImprovingthePerformanceofUpdatesandDeletions"></a>
<p CLASS="heading4OrgHeading2h2">Improving the Performance of Updates and Deletions</p>
<p CLASS="Textttext">Probably the simplest way to improve the performance of updates and deletions<img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">especially if your remote table has many fields<img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">is to add a <span CLASS="NewTermntrm">version field</span> (sometimes called a <span CLASS="NewTermntrm">timestamp</span>) to the remote table. A version field is maintained by the server, and its value automatically changes each time the record is updated. Typically, you can't read the contents of a version field, but Microsoft Access uses it to detect changes in records.
<p CLASS="Textttext">When updating or deleting a record, Microsoft Access checks to see if the version field has changed. If it has, the update or deletion is canceled to avoid overwriting another user's changes. If the table doesn't have a version field, Microsoft Access compares all the old field values to their current values in order to determine whether data has changed. This is less efficient and generates more network traffic. Moreover, when Microsoft Access checks values, data that hasn't changed occasionally appears as if it had, either because of inaccuracies inherent in comparing floating-point numbers, or because Memo and OLE Object fields aren't compared at all.
<p CLASS="Textttext">To add a version field to a remote table, you can use the ALTER TABLE statement. For example, the following command adds a version field to a SQL Server table:</p>
<p CLASS="CodeTextct">ALTER TABLE RemoteTable ADD VersionCol TIMESTAMP</p>
<p CLASS="Textttext">You can run this statement as a pass-through query in Microsoft Access or use the administration tools available on your server to add the field. If you add fields to a remote table, relink the table to inform Microsoft Access of the new field's existence.</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>Not all servers support version fields. To see if yours does, check the server's documentation.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For more information on the ALTER TABLE statement, search the Help index for &quot;ALTER TABLE statement.&quot;</p>
<a NAME="4UsingTransactions"></a>
<p CLASS="heading4OrgHeading2h2">Using Transactions</p>
<p CLASS="Textttext">A powerful way to improve the performance of updates as well as multiuser concurrency is to use transactions. With transactions, Microsoft Jet accumulates multiple updates and writes them as a single batch. By performing operations as a batch, transactions ensure that operations either succeed or fail as a group, shielding other users from partially completed updates.
<p CLASS="Textttext">You can control transactions in Visual Basic only by using the <span CLASS="ElementNameeln">BeginTrans</span>, <span CLASS="ElementNameeln">CommitTrans</span>, and <span CLASS="ElementNameeln">Rollback</span> methods of the <span CLASS="ElementNameeln">Workspace</span> object. To improve the performance of your application, use a transaction with:</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspA sequence of <span CLASS="ElementNameeln">Recordset</span> updates, insertions, or deletions, or any combination of the three.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspA sequence of action queries.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspA sequence of pass-through queries that change data.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspAny combination of these operations in a sequence.</p>
<p CLASS="TipTexttpt"><span CLASS="TipHeadingtph">Tip&nbsp;&nbsp;&nbsp;</span>On most servers, transactions generate locks that prevent other users from updating or even reading data affected by the transaction until it's committed or rolled back. Therefore, keep your transactions as short as possible, and avoid placing code sequences that wait for a user's input inside a transaction.</p>
<a NAME="5BatchingUpdates"></a>
<p CLASS="heading5OrgHeading3h3">Batching Updates</p>
<p CLASS="Textttext">The following example demonstrates how to use a transaction in Visual Basic to perform multiple updates in a batch. It uses three pass-through queries in a transaction to transfer money from a savings account to a checking account. The Microsoft Access application (the client) sends queries and updates to the server and retrieves the data it needs.</p>
<p CLASS="CodeTextct">Sub TransferFunds()<br>&nbsp;&nbsp;&amp;nbspDim wrkBatchUpdate As Workspace, dbsTransaction As Database<br>&nbsp;&nbsp;&amp;nbspDim qdfUpdateQuery As QueryDef<br>&nbsp;&nbsp;&amp;nbspOn Error GoTo TransferFailed<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&amp;nbspSet wrkBatchUpdate = DBEngine.Workspaces(0)<br>&nbsp;&nbsp;&amp;nbspSet dbsTransaction = wrkBatchUpdate.Databases(0)<br>&nbsp;&nbsp;&amp;nbspwrkBatchUpdate.BeginTrans&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Begin transaction.<br>&nbsp;&nbsp;&nbsp;' Create pass-through query.<br>&nbsp;&nbsp;&amp;nbspSet qdfUpdateQuery = dbsTransaction.CreateQueryDef(&quot;&quot;)<br>&nbsp;&nbsp;&amp;nbspWith qdfUpdateQuery<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Connect = &quot;ODBC;DSN=Bank;UID=teller;DATABASE=access&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.ReturnsRecords = False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.SQL = &quot;UPDATE Accounts SET Balance = Balance - 100 &quot; &amp; _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE AccountID = 'SMITH_SAV'&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Subtract from savings account.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.SQL = &quot;UPDATE Accounts SET Balance = Balance + 100 &quot; &amp; _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;WHERE AccountID = 'SMITH_CHK'&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Add to checking account.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.SQL = &quot;INSERT INTO LogBook &quot; &amp; _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;(Type, Source, Destination, Amount)&quot; &amp; _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;VALUES ('Transfer', 'SMITH_SAV', 'SMITH_CHK', 100)&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Log transaction.<br>&nbsp;&nbsp;&amp;nbspEnd With<br>&nbsp;&nbsp;&amp;nbspwrkBatchUpdate.CommitTrans&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Commit transaction.<br>&nbsp;&nbsp;&amp;nbspExit Sub<br>TransferFailed:<br>&nbsp;&nbsp;&amp;nbspMsgBox Err<br>&nbsp;&nbsp;&amp;nbspwrkBatchUpdate.Rollback&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Roll back if any Execute fails.<br>&nbsp;&nbsp;&amp;nbspExit Sub<br>End Sub</p>
<p CLASS="Textttext">Note the use of the <span CLASS="ElementNameeln">CreateQueryDef</span> method to create a temporary pass-through query. This technique introduces the minimum possible overhead for Microsoft Jet, while still making use of transactions transparently through Visual Basic. However, it limits functionality to what the server provides, and it is more difficult to define a parameter query this way.</p>
<a NAME="5BatchingInsertions"></a>
<p CLASS="heading5OrgHeading3h3">Batching Insertions</p>
<p CLASS="Textttext">If your application provides data-entry forms for multiple records of data, such as an order entry system, you can improve performance and robustness by saving new records in a local holding table and then transferring batches of records from the holding table to the server all at once within a transaction.</p>
<p CLASS="heading9ListProcedureHeadinglproch"><span CLASS="ProcedureIconproci"><img SRC="../images/bluetri.jpg" ALIGN="LEFT" WIDTH="9" HEIGHT="17">&nbsp;&nbsp;&nbsp;</span>To insert a batch of records on a server by using a transaction</p>
<p CLASS="ListProcedureItem1lproc"><span CLASS="lproc">1</span>&nbsp;&nbsp;&amp;nbspCreate empty local tables that contain the same fields as your remote tables.</p>
<p CLASS="ListProcedureItem1lproc"><span CLASS="lproc">2</span>&nbsp;&nbsp;&amp;nbspCreate a data-entry form based on these local tables.</p>
<p CLASS="ListProcedureItem1lproc"><span CLASS="lproc">3</span>&nbsp;&nbsp;&amp;nbspOn the form, create a command button labeled &quot;Post Records&quot; for sending records to the server.</p>
<p CLASS="ListProcedureItem1lproc"><span CLASS="lproc">4</span>&nbsp;&nbsp;&amp;nbspCreate an event procedure for the button's Click event that copies the local records to the server tables and deletes the records from the local tables. The event procedure should perform all insertions and deletions within a transaction.</p>
<p CLASS="Textttext">For example, suppose you have an Orders form that contains an Order Details subform based on two local tables, LclOrders and LclOrderDetails. The user enters a new order and a group of detail records in the subform. When the user clicks the PostRecords command button on the Orders form, the following procedure runs:</p>
<p CLASS="CodeTextct">Private Sub PostRecords_Click<br>&nbsp;&nbsp;&amp;nbspDim wrkTransaction As Workspace, dbsPosting As Database<br>&nbsp;&nbsp;&amp;nbspOn Error GoTo TransferFailed<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&amp;nbspSet wrkTransaction = DBEngine.Workspaces(0)<br>&nbsp;&nbsp;&amp;nbspSet dbsPosting = wrkTransaction.Databases(0)<br>&nbsp;&nbsp;&amp;nbspwrkTransaction.BeginTrans&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Begin transaction.<br>&nbsp;&nbsp;&amp;nbspWith dbsPosting<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute &quot;INSERT INTO RmtOrdersEmpty SELECT * &quot; &amp; _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;FROM LclOrders&quot;, dbFailOnError<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute &quot;INSERT INTO RmtOrderDetailsEmpty SELECT * &quot; &amp; _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;FROM LclOrderDetails&quot;, dbFailOnError<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute &quot;DELETE FROM LclOrders&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Execute &quot;DELETE FROM LclOrderDetails&quot;<br>&nbsp;&nbsp;&amp;nbspEnd With<br>&nbsp;&nbsp;&amp;nbspwrkTransaction.CommitTrans&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Commit transaction.<br>&nbsp;&nbsp;&amp;nbspMe.Requery&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Clear form for next order entry.<br>&nbsp;&nbsp;&amp;nbspExit Sub<br>TransferFailed:<br>&nbsp;&nbsp;&amp;nbspMsgBox Err<br>&nbsp;&nbsp;&amp;nbspwrkTransaction.Rollback&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Roll back if any Execute fails.<br>&nbsp;&nbsp;&amp;nbspExit Sub<br>End Sub</p>
<p CLASS="Textttext">This procedure doesn't insert the records directly into the tables on the server. RmtOrdersEmpty and RmtOrderDetailsEmpty aren't the remote tables; instead, they are the following queries, which are based on the linked remote tables but return no records.</p>
<p CLASS="CodeTextct">SELECT * FROM RmtOrders WHERE False<br>SELECT * FROM RmtOrderDetails WHERE False</p>
<p CLASS="Textttext">For these append queries, inserting records into empty queries on linked remote tables provides the fastest possible speed, similar to opening a <span CLASS="ElementNameeln">Recordset</span> by using the <span CLASS="ElementNameeln">OpenRecordset</span> method with the <span CLASS="ElementNameeln">dbAppendOnly</span> constant.
<p CLASS="Textttext">After this code deletes the records from the local tables, it uses the <span CLASS="ElementNameeln">Requery</span> method to present the user with a blank form for the next entry. In addition, it uses the <span CLASS="ElementNameeln">dbFailOnError</span> constant with the two append queries so that an error occurs if any part of either query fails. The error handler then rolls back any changes made.</p>
<a NAME="5LimitationsofTransactions"></a>
<p CLASS="heading5OrgHeading3h3">Limitations of Transactions</p>
<p CLASS="Textttext">Although using transactions can improve the performance of your client/server applications, they do have several limitations:</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspAlthough you can nest transactions in Visual Basic, servers generally don't support nested transactions. Microsoft Access sends only the first-level transaction to a server.</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspDepending on your server, some pass-through queries may not be allowed within a transaction. For example, some servers don't allow data-definition queries within transactions. To determine the limits for your server, check its documentation.</p>
<p CLASS="Textttext">Avoid sending server-specific transaction commands in pass-through queries because these commands may confuse the internal tracking of server transactions performed by Microsoft Jet. Instead, use the <span CLASS="ElementNameeln">BeginTrans</span>, <span CLASS="ElementNameeln">CommitTrans</span>, and <span CLASS="ElementNameeln">Rollback</span> methods. Microsoft Access translates these methods into the appropriate server commands.
<p CLASS="Textttext">When you work with local data, each <span CLASS="ElementNameeln">Workspace</span> object represents an isolated transaction space. However, this isn't the case for remote data used within the <span CLASS="ElementNameeln">Workspace</span> object. You can force a <span CLASS="ElementNameeln">Workspace</span> object to have a distinct remote transaction space by setting the <span CLASS="ElementNameeln">IsolateODBCTrans</span> property of the <span CLASS="ElementNameeln">Workspace</span> object to <span CLASS="ElementNameeln">True</span>. This prevents the <span CLASS="ElementNameeln">Workspace</span> object from sharing connections with other <span CLASS="ElementNameeln">Workspaces</span>, thus guaranteeing transaction isolation. You need to do this only if you use multiple concurrent transactions on your server (which isn't very common).</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For more information on the <span CLASS="ElementNameeln">IsolateODBCTrans</span> property, search the Help index for &quot;IsolateODBCTrans property.&quot; For more information on transactions, see Chapter 9, <a HREF="../chapters/ba09_1.htm" OnClick="SyncURL(&quot;chapters/ba09_1.htm&quot;)">&quot;Working with Records and Fields,&quot;</a> or search the Help index for &quot;transactions in DAO.&quot;</p>
<a NAME="4UsingRemoteDataCachinginRecordsets"></a>
<p CLASS="heading4OrgHeading2h2">Using Remote Data Caching in Recordsets</p>
<p CLASS="Textttext">Another way to improve your application's performance is to cache remote data. Datasheets and forms based on remote data automatically cache data, but dynasets created in Visual Basic do not. If you'll be moving around in and retrieving data from a small range of records (less than 200), you should explicitly use remote data caching. You can use the <span CLASS="ElementNameeln">CacheStart</span> and <span CLASS="ElementNameeln">CacheSize</span> properties to specify the range you want within the <span CLASS="ElementNameeln">Recordset</span>. Use the <span CLASS="ElementNameeln">FillCache</span> method to quickly fill all or part of this range with data from the server.
<p CLASS="Textttext">Caching also helps when you simulate an action query by using a <span CLASS="ElementNameeln">Recordset</span>. You may want to do this if the operations involved are too complex for an action query. Typically, to simulate an action query, you advance through each record in the <span CLASS="ElementNameeln">Recordset</span>, analyze the record's contents, and possibly update or delete the record. You can greatly improve performance if you move through the<span CLASS="ElementNameeln"> Recordset</span> and fill the cache before processing every 100 records, even if you make only one pass through the <span CLASS="ElementNameeln">Recordset</span>.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For more information on data caching, search the Help index for &quot;caching data.&quot;</p>
<a NAME="4UsingtheMSysConfTabletoControlBackgroundPopulation"></a>
<p CLASS="heading4OrgHeading2h2">Using the MSysConf Table to Control Background Population</p>
<p CLASS="Textttext">You can control <span CLASS="NewTermntrm">background population</span>, which is the rate at which Microsoft Access reads records from the server during idle time, by creating a table named MSysConf on your server. In the MSysConf table, you can set the number of rows of data that are retrieved at one time and the number of seconds of delay between each retrieval. If you're experiencing excessive read locking on the server, you can adjust the table settings to increase background population speed. If too much network traffic is generated by background population, adjust the settings to slow it down.</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>Unlike Microsoft Access forms and datasheets, <span CLASS="ElementNameeln">Recordset</span> objects you create in Visual Basic code aren't populated during idle time. If your server places read locks on records as they are retrieved, you shouldn't remain on a record or page for an extended period of time. Partially populated <span CLASS="ElementNameeln">Recordset</span> objects in your Visual Basic code can prevent other users from updating data. If the <span CLASS="ElementNameeln">Recordset</span> is small, you can use the <span CLASS="ElementNameeln">MoveLast</span> method to fully populate the <span CLASS="ElementNameeln">Recordset</span> and clear any such locks. If the <span CLASS="ElementNameeln">Recordset</span> is large, you may want to use a Timer event procedure to implement your own version of background population.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For more information on the MSysConf table, search the Help index for &quot;MSysConf table.&quot;</p>
<p><!--DocFooterStart-->
<p><span CLASS="copyright"><a HREF="cpyright.htm">© 1996 Microsoft Corporation. All rights reserved.</a></span>
<p><!--DocFooterEnd-->
<a HREF="ba19_7.htm" OnClick="SyncURL(&quot;chapters/ba19_7.htm&quot;)"><img SRC="..\images\nextpage.gif" ALT="Next Page" ALIGN="RIGHT" BORDER="0"></a><!--mstheme--></font></body></html>
