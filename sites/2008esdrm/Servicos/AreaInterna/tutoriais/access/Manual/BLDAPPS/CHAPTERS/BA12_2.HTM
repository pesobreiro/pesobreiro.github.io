<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html><head><title>Using Dynamic-Link Libraries</title>
<link REL="STYLESHEET" HREF="naetugp.css" TYPE="text/css">
<script Language="VBScript">
Dim look
Sub SyncURL(look)
if right(top.frames(0).frames(1).location.href, 10)="toc_tc.htm" then
top.frames(0).frames(1).TreeCtl1.SyncToURL(look)
end if
End Sub
</script>
<meta name="Microsoft Theme" content="expeditn 011, default"></head>
<!--DocHeaderStart-->
<body background="../../../../_themes/expeditn/exptextb.jpg" bgcolor="#FFFFFF" text="#000000" link="#993300" vlink="#666600" alink="#CC3300"><!--mstheme--><font face="book antiqua, times new roman, times"><a HREF="ba12_1.htm" OnClick="SyncURL(&quot;chapters/ba12_1.htm&quot;)"><img SRC="..\images\prevpage.gif" ALT="Previous Page" ALIGN="RIGHT" BORDER="0"></a>
<!--DocHeaderEnd-->
<!-- This is a PANDA Generated HTML file. The source is a WinWord Document. -->
<a NAME="3UsingDynamicLinkLibraries"></a>
<p CLASS="heading3OrgHeading1h1">Using Dynamic-Link Libraries</p>
<p CLASS="Textttext">A <span CLASS="NewTermntrm">dynamic-link library</span> (DLL) is a library of procedures that applications can link to and use at run time rather than link to statically at compile time. This means that DLLs can be updated without updating the application, and many applications can share a single DLL. Microsoft Windows is itself composed of several DLLs that contain the procedures all applications use to perform their activities, such as displaying windows and graphics, managing memory, and so on. These procedures are sometimes referred to as the Windows application programming interface (API).
<p CLASS="Textttext">Your Microsoft Access applications can call the procedures in Windows DLLs to perform special actions that you can't perform directly in Microsoft Access. You can also call procedures in other DLLs you have in your system.
<p CLASS="Textttext">Because DLL procedures reside in files that are external to your Microsoft Access application, you have to give Microsoft Access some information so that it can find and run the DLL procedures you want to use. You provide this information with the <span CLASS="ElementNameeln">Declare</span> statement. Once you have declared a DLL procedure, you can use it in your code like any other procedure. However, you have to be especially careful about the arguments that you pass to DLL procedures, or the procedure may not be able to interpret the data and may not function as you expect.
<p CLASS="Textttext">There are two basic steps in using a DLL procedure:</p>
<p CLASS="ListSequentialItem1ls">1.&nbsp;&amp;nbspFirst, tell Microsoft Access about the procedure by using a <span CLASS="ElementNameeln">Declare</span> statement. You must explicitly declare the procedure before you can call it.</p>
<p CLASS="ListSequentialItem1ls">2.&nbsp;&amp;nbspNext, call the procedure.</p>
<p CLASS="Textttext">You declare a DLL procedure only once. After declaring the procedure, you can call it any number of times from anywhere in your application.</p>
<!--mstheme--></font><table CELLPADDING="3" BORDER="2" BORDERCOLOR="#0000FF" bordercolordark="#660000" bordercolorlight="#CC9966"><tr BGCOLOR="#FFFFFF"><td><!--mstheme--><font face="book antiqua, times new roman, times">
<p CLASS="SidebarHeadingsbrh">Converting Applications That Call 16-Bit DLLs</p>
<p CLASS="SidebarTextsbrt">If a database created in Microsoft Access version 2.<span CLASS="NewTermntrm">x</span> or earlier called procedures in the Windows API, you need to make some changes in your code when you convert the database to Microsoft Access 97.
 These earlier versions of Microsoft Access were 16-bit applications and ran on 16-bit versions of Windows. Microsoft Access 97 is a 32-bit application and runs only on 32-bit versions of Windows. 
<p CLASS="SidebarTextsbrt">If your existing Access Basic code made calls to a 16-bit Windows API, you need to modify these calls when you convert your database to Microsoft Access 97. For example, you need to change the names of the DLLs and the data types of some parameters. Also, note that 32-bit API procedure names are case-sensitive, so you need to make sure that the calls you make exactly match the procedure names in the Windows DLLs. </p>
<p CLASS="SidebarTextsbrt">There is a tool called the Windows API Viewer included with both Visual Basic and Microsoft Office 97, Developer Edition. This tool includes Visual Basic syntax for all 32-bit declarations, data types, and constants. You can copy and paste these declarations, data types, and constants into your Microsoft Access applications.</p>
<p CLASS="SidebarCrossRefTextsbrcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For tips on converting code that calls a DLL, search the Help index for &quot;converting code.&quot;</p>
<p CLASS="SidebarTextsbrt">If your Visual Basic code makes calls into a custom 16-bit DLL, either the developer of the DLL must provide a 32-bit compatibility layer for the DLL, or the DLL source code must be recompiled into a 32-bit version of the DLL.
<p CLASS="SidebarEndSpacingsbres"></p><!--mstheme--></font></td></tr></table><!--mstheme--><font face="book antiqua, times new roman, times">
<a NAME="4DeclaringDLLProcedures"></a>
<p CLASS="heading4OrgHeading2h2">Declaring DLL Procedures</p>
<p CLASS="Textttext">To declare a DLL procedure, place a <span CLASS="ElementNameeln">Declare</span> statement in the Declarations section of a form, report, or standard module. If you declare a DLL procedure in a standard module, it can be called by code anywhere in your application. If you declare a DLL procedure in a form or report module, you must use the <span CLASS="ElementNameeln">Private </span>keyword. The DLL procedure can only be called by other code in the form or report module it resides in.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For the complete syntax of the <span CLASS="ElementNameeln">Declare</span> statement, search the Help index for &quot;Declare statement.&quot;</p>
<p CLASS="Textttext">If the procedure doesn't return a value, declare it as a <span CLASS="ElementNameeln">Sub </span>procedure. For example:</p>
<p CLASS="CodeTextct">Declare Sub InvertRect Lib &quot;user32&quot;(ByVal hDC&nbsp;&nbsp;&amp;nbspAs Long, lpRect As RECT)</p>
<p CLASS="Textttext">If the procedure does return a value, declare it as a <span CLASS="ElementNameeln">Function</span> procedure. For example:</p>
<p CLASS="CodeTextct">Declare Function GetSystemMetrics Lib &quot;user32&quot;(ByVal nIndex As Long) As Long</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>The procedure name you use in a <span CLASS="ElementNameeln">Declare </span>statement is case-sensitive. The library name is also case-sensitive.</p>
<p CLASS="Textttext">Notice the <span CLASS="ElementNameeln">Lib</span> and <span CLASS="ElementNameeln">ByVal</span> keywords in the <span CLASS="ElementNameeln">Declare</span> statement. The <span CLASS="ElementNameeln">Declare</span> statement can also contain an optional <span CLASS="ElementNameeln">Alias</span> keyword. The use of these keywords is explained later in this section.
<p CLASS="Textttext">The declarations for DLL procedures can get fairly complex. If you plan to declare and call DLL procedures in the Windows API, it's a good idea to have complete documentation of the API for reference. You can find detailed documentation of the Windows API in each of these Microsoft products:</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspVisual Basic Professional Edition</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspWin32 Software Development Kit</p>
<p CLASS="ListBulletedItem1lb1"><img SRC="../images/bullet.jpg" WIDTH="5" HEIGHT="7">&amp;nbspVisual C++ version 4.0</p>
<p CLASS="Textttext">The rest of this section explains the syntax of the <span CLASS="ElementNameeln">Declare</span> statement in detail.</p>
<a NAME="5SpecifyingtheLibrary"></a>
<p CLASS="heading5OrgHeading3h3">Specifying the Library</p>
<p CLASS="Textttext">The <span CLASS="ElementNameeln">Lib</span> <span CLASS="NewTermntrm">libname</span> clause in the <span CLASS="ElementNameeln">Declare</span> statement tells Microsoft Access where to find the dynamic-link library. For the Windows DLLs, this is either <span CLASS="CodeTextEmbeddedcte">&quot;user32&quot;</span>, <span CLASS="CodeTextEmbeddedcte">&quot;gdi32&quot;</span>, <span CLASS="CodeTextEmbeddedcte">&quot;kernel32&quot;</span>, or one of the other system DLLs such as <span CLASS="CodeTextEmbeddedcte">&quot;WINMM&quot;</span>. For other DLLs, <span CLASS="NewTermntrm">libname</span> is a file name that can include a path. For example:</p>
<p CLASS="CodeTextct">Declare Function LzCopy Lib &quot;C:\Win\LzExpand.dll&quot; (ByVal S As Long, _<br>&nbsp;&nbsp;&amp;nbspByVal D As Long) As Long</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>If no path is included in the library name, Visual Basic searches the default system path, then the \Windows folder, and finally the \Windows\System subfolder.</p>
<a NAME="5PassingArgumentsbyValueorbyReference"></a>
<p CLASS="heading5OrgHeading3h3">Passing Arguments by Value or by Reference</p>
<p CLASS="Textttext">By default, Microsoft Access passes all arguments <span CLASS="NewTermntrm">by reference</span>, which means that Visual Basic passes a 32-bit address where the value is stored instead of passing the actual value of the argument. If you want to clarify how data is being passed, you can use the <span CLASS="ElementNameeln">ByRef </span>keyword.
<p CLASS="Textttext">Many DLL procedures expect an argument to be passed <span CLASS="NewTermntrm">by value</span>, which means that the procedure expects the actual value of the argument instead of its memory location. If you pass an argument by reference to a procedure that expects an argument passed by value, the procedure can't interpret the data and doesn't operate properly.
<p CLASS="Textttext">To pass an argument by value, place the <span CLASS="ElementNameeln">ByVal</span> keyword in front of the argument declaration in the <span CLASS="ElementNameeln">Declare</span> statement. This ensures that each time you call the procedure, the argument is passed by value.
<p CLASS="Textttext">For example, the following InvertRect procedure accepts its first argument by value and its second argument by reference:</p>
<p CLASS="CodeTextct">Declare Sub InvertRect Lib &quot;user32&quot;(ByVal hDC&nbsp;&nbsp;&amp;nbspAs Long, lpRect As RECT)</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>When you're looking at DLL procedure documentation that uses C-language syntax, remember that C passes by value all arguments except arrays.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For more information on passing arguments by value or by reference, see <a HREF="../chapters/ba04_3.htm#4ArgumentDataTypes" OnClick="SyncURL(&quot;chapters/ba04_3.htm&quot;)">&quot;Argument Data Types&quot;</a> in Chapter 4, &quot;Working with Variables, Data Types, and Constants.&quot;</p>
<a NAME="5PassingFlexibleArgumentTypes"></a>
<p CLASS="heading5OrgHeading3h3">Passing Flexible Argument Types</p>
<p CLASS="Textttext">Some DLL procedures can accept more than one type of data for the same argument. To pass more than one type of data, declare the argument with the <span CLASS="ElementNameeln">As</span> <span CLASS="ElementNameeln">Any</span> keyword to remove type restrictions. For example, you can declare a procedure as follows:</p>
<p CLASS="CodeTextct">Declare Function FindWindow Lib &quot;user32&quot; Alias &quot;FindWindowA&quot; _<br>&nbsp;&nbsp;&nbsp;(ByVal lpClassName As Any, ByVal lpWindowName As Any) As Long</p>
<p CLASS="Textttext">Then you can call this procedure and pass either a string or a <span CLASS="ElementNameeln">Null</span> value to each function argument:</p>
<p CLASS="CodeTextct">Function WindowExist ()<br>&nbsp;&nbsp;&nbsp;' Assign values to constants that will be passed to FindWindow.<br>&nbsp;&nbsp;&amp;nbspConst lpClassName = &quot;SciCalc&quot;<br>&nbsp;&nbsp;&amp;nbspConst lpWindowName = &quot;Calculator&quot;<br>&nbsp;&nbsp;&nbsp;' This demonstrates three different ways to call FindWindow:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' 1. The Class name only.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' 2. The Caption only.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' 3. Both the Class name and the Caption.<br>&nbsp;&nbsp;&nbsp;' A Null is represented by the symbol &quot;0&amp;&quot;.<br>&nbsp;&nbsp;&amp;nbspMsgBox &quot;Window Handle = &quot; &amp; FindWindow(lpClassName, 0&amp;)<br>&nbsp;&nbsp;&amp;nbspMsgBox &quot;Window Handle = &quot; &amp; FindWindow(0&amp;, lpWindowName)<br>&nbsp;&nbsp;&amp;nbspMsgBox &quot;Window Handle = &quot; &amp; FindWindow(lpClassName, lpWindowName)<br>&nbsp;&nbsp;&amp;nbspWindowExist = FindWindow(lpClassName, 0&amp;)<br>&nbsp;&nbsp;&nbsp;' Any of the above FindWindow calls could be used to return the<br>&nbsp;&nbsp;&nbsp;' window handle.<br>End Function</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>The preceding code uses window handles to identify the window returned by the FindWindow function. For more information on handles, see <a HREF="../chapters/ba12_2.htm#6Handles" OnClick="SyncURL(&quot;chapters/ba12_2.htm&quot;)">&quot;Handles&quot;</a> later in this chapter.</p>
<p CLASS="Textttext">When you remove type restrictions, Microsoft Access assumes the argument is passed by reference. Use the <span CLASS="ElementNameeln">ByVal</span> keyword in the actual call to the procedure to pass arguments by value. When passing strings, you must use the <span CLASS="ElementNameeln">ByVal</span> keyword to convert a Visual Basic string into a null-terminated string.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For more information on passing strings, see <a HREF="../chapters/ba12_2.htm#5CallingDLLProcedureswithSpecificDataTypes" OnClick="SyncURL(&quot;chapters/ba12_2.htm&quot;)">&quot;Calling DLL Procedures with Specific Data Types&quot;</a> later in this chapter.</p>
<a NAME="5UsingNonstandardNames"></a>
<p CLASS="heading5OrgHeading3h3">Using Nonstandard Names</p>
<p CLASS="Textttext">Occasionally, a DLL procedure has a name that isn't a valid identifier in Microsoft Access. It may have an invalid character (such as a hyphen), or be the same as a Visual Basic keyword (such as <span CLASS="ElementNameeln">GetObject</span>). When either is the case, use the <span CLASS="ElementNameeln">Alias</span> keyword.
<p CLASS="Textttext">For example, some procedures in Windows DLLs begin with an underscore character. While you can use an underscore in a Visual Basic identifier, you can't begin an identifier with an underscore. To use one of these procedures, you must declare the procedure with the <span CLASS="ElementNameeln">Alias </span>keyword.</p>
<p CLASS="CodeTextct">Declare Function LOpen Lib &quot;kernel32&quot; Alias &quot;_lopen&quot; (ByVal _<br>&nbsp;&nbsp;&amp;nbsplpPathName As String, ByVal ReadWrite As Long) As Long</p>
<p CLASS="Textttext">In this example, <span CLASS="CodeTextEmbeddedcte">LOpen</span> becomes the name of the procedure as it's referred to in your Microsoft Access procedures. The name <span CLASS="CodeTextEmbeddedcte">_lopen</span> is the name recognized in the DLL.</p>
<a NAME="5UsingOrdinalNumbers"></a>
<p CLASS="heading5OrgHeading3h3">Using Ordinal Numbers</p>
<p CLASS="Textttext">In addition to a name, all DLL procedures can be identified by an <span CLASS="NewTermntrm">ordinal number</span> that specifies the position of the procedure in the DLL. Some DLLs don't include the names of their procedures and require you to use ordinal numbers when declaring the procedures they contain. Using an ordinal number consumes less memory in your finished application and is slightly faster than identifying a procedure in a DLL by name. You may also want to use ordinal numbers when declaring other DLL procedures. To obtain the ordinal number of the DLL procedure you want to declare, consult the documentation for the DLL.
<p CLASS="Textttext">To declare a DLL procedure by ordinal number, use the <span CLASS="ElementNameeln">Alias</span> keyword with a string containing the number sign character (#) and the ordinal number of the procedure. For example, if you want to call a function called GetAppSettings in a library called Utilities, and that function has the ordinal number 47, you can declare the DLL procedure as follows:</p>
<p CLASS="CodeTextct">Declare Function GetAppSettings Lib &quot;Utilities&quot; Alias &quot;#47&quot; () As Long</p>
<p CLASS="Textttext">You could specify any valid name for the procedure in this case, because Visual Basic is using the ordinal number to find the procedure in the DLL.</p>
<a NAME="4CallingDLLProcedures"></a>
<p CLASS="heading4OrgHeading2h2">Calling DLL Procedures</p>
<p CLASS="Textttext">Once a procedure is declared, you can call it just as you would a Microsoft Access statement or function. For example:</p>
<p CLASS="CodeTextct">Private Sub Form_Load()<br>&nbsp;&nbsp;&amp;nbspConst SM_MOUSEPRESENT = 19<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&amp;nbspIf GetSystemMetrics(SM_MOUSEPRESENT) Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspMsgBox &quot;Mouse installed&quot;<br>&nbsp;&nbsp;&amp;nbspEnd If<br>End Sub</p>
<p CLASS="ImportantTextit"><span CLASS="ImportantHeadingih">Important&nbsp;&nbsp;&nbsp;</span>Microsoft Access can't verify that you are passing correct values to a DLL procedure. If you pass incorrect values, the procedure may fail, which may cause your Microsoft Access application to shut down. This doesn't cause permanent harm to your application, but you'll have to reload and restart the application. Take care when using DLL procedures, and save your work often.</p>
<a NAME="5CallingDLLProcedureswithSpecificDataTypes"></a>
<p CLASS="heading5OrgHeading3h3">Calling DLL Procedures with Specific Data Types</p>
<p CLASS="Textttext">Microsoft Access incorporates a rich assortment of data types, including many<img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">such as variable-length strings, <span CLASS="ElementNameeln">Currency</span>, and properties<img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">that aren't supported by the procedures in most dynamic-link libraries. Therefore, you must take care when using Visual Basic variables with DLL procedures.</p>
<a NAME="6Strings"></a>
<p CLASS="heading6OrgHeading4h4">Strings</p>
<p CLASS="Textttext">The procedures in most DLLs (and all the procedures in the Windows API) expect standard C strings (sometimes called ASCIIZ strings) which end in a null character (binary zero). If a DLL procedure expects a null-terminated string as an argument, declare the argument as a string with the <span CLASS="ElementNameeln">ByVal</span> keyword. When used with a string argument, the <span CLASS="ElementNameeln">ByVal</span> keyword tells Microsoft Access to pass the string as a null-terminated string.</p>
<a NAME="6DLLProceduresThatModifyStrings"></a>
<p CLASS="heading6OrgHeading4h4">DLL Procedures That Modify Strings</p>
<p CLASS="Textttext">Strings are always passed to DLL procedures by reference. (The <span CLASS="ElementNameeln">ByVal</span> keyword for string arguments specifies that Microsoft Access should convert the string to a null-terminated string, not that the string should be passed by value.) A DLL procedure can therefore modify a Microsoft Access string variable it receives as an argument. However, be careful when calling a DLL procedure that modifies a string. A DLL can't increase the length of a Microsoft Access string; if the string isn't long enough, the DLL simply writes beyond the end of the string. This corrupts other areas of memory. You can avoid this problem by making the string argument long enough that the DLL procedure never writes past the end of it.
<p CLASS="Textttext">For example, the GetWindowsDirectory procedure returns the path for the Windows directory in its first argument.</p>
<p CLASS="CodeTextct">Declare Function GetWindowsDirectory Lib &quot;kernel32&quot; Alias _<br>&nbsp;&nbsp;&nbsp;&quot;GetWindowsDirectoryA&quot; (ByVal lpBuffer As String, _<br>&nbsp;&nbsp;&amp;nbspByVal nSize As Long) As Long</p>
<p CLASS="Textttext">One way to call this procedure is to make the returned argument a specified length by filling it with characters<img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">in this case, null (ANSI zero) characters.</p>
<p CLASS="CodeTextct">strPath = String(255, 0)<br>strWorked = GetWindowsDirectory(strPath, Len(strPath))</p>
<p CLASS="Textttext">Another way to call this procedure is to define the string as fixed-length.</p>
<p CLASS="CodeTextct">Dim strPath As String * 255<br>strWorked = GetWindowsDirectory(strPath, Len(strPath))</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>The Windows DLL procedures could possibly return strings longer than 255 characters. Always consult the documentation for information on the procedure at hand.</p>
<p CLASS="Textttext">You can use Microsoft Access strings when the DLL procedure calls for a memory buffer. Use one of the processes outlined previously in this section to ensure that the string is long enough to accept whatever data the procedure supplies.</p>
<a NAME="6Arrays"></a>
<p CLASS="heading6OrgHeading4h4">Arrays</p>
<p CLASS="Textttext">You pass individual elements of an array in the same way you pass any variable that has the same type as the base type of the array. For example, the sndPlaySound function plays a digitized sound (.wav) file (if you have the sound hardware and drivers that can use these files).</p>
<p CLASS="CodeTextct">Declare Function sndPlaySound Lib &quot;<span CLASS="CodeTextEmbeddedcte">WINMM</span>&quot; (ByVal lpszSoundName _<br>&nbsp;&nbsp;&amp;nbspAs String, ByVal uFlags As Integer) As Integer</p>
<p CLASS="Textttext">You can use the sndPlaySound function to play a series of .wav files stored in an array.</p>
<p CLASS="CodeTextct">Dim intX As Integer, intWorked As Integer<br>For intX = 0 To UBound(WaveFiles)<br>&nbsp;&nbsp;&amp;nbspintWorked = sndPlaySound(WaveFile(intX), 0)<br>Next intX</p>
<p CLASS="Textttext">You pass an entire numeric array by passing the first element of the array by reference. This works because numeric array data is always laid out sequentially in memory. A DLL procedure, if passed the first element of an array, has access to all the array's elements. For example, if you made a call to a function in a C library that contained the following header:</p>
<p CLASS="CodeTextct">int CalcMean(int intArray, int intElements)<br>/*Returns the arithmetic mean of an array of integers.*/</p>
<p CLASS="Textttext">Then you would declare the function in your Visual Basic module:</p>
<p CLASS="CodeTextct">Declare Function CalcMean Lib &quot;Calc.dll&quot; (intArray As Integer, _<br>&nbsp;&nbsp;&amp;nbspintElements As Integer) As Integer</p>
<p CLASS="Textttext">And you would pass the array to the library function by specifying the first element of the array as one of the function arguments, as shown in the last line of the following procedure:</p>
<p CLASS="CodeTextct">Function AvgOfRecords ()<br>&nbsp;&nbsp;&amp;nbspDim intN() As Integer<br>&nbsp;&nbsp;&amp;nbspDim dbs As Database, rst As Recordset<br>&nbsp;&nbsp;&amp;nbspDim intTotal As Integer, intX As Integer<br>&nbsp;&nbsp;&amp;nbspSet dbs = CurrentDb<br>&nbsp;&nbsp;&amp;nbspSet rst = dbs.OpenRecordset(&quot;Order Details&quot;)<br>&nbsp;&nbsp;&amp;nbsprst.MoveLast<br>&nbsp;&nbsp;&amp;nbspintTotal = rst.RecordCount<br>&nbsp;&nbsp;&nbsp;' ReDim the array to the # of recs in the table.<br>&nbsp;&nbsp;&amp;nbspReDim intN(intTotal)<br>&nbsp;&nbsp;&amp;nbsprst.MoveFirst<br>&nbsp;&nbsp;&nbsp;' Fill the array with values from table.<br>&nbsp;&nbsp;&amp;nbspFor intX = 0 To (intTotal - 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspintN(intX) = rst!Quantity<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbsprst.MoveNext<br>&nbsp;&nbsp;&amp;nbspNext intX<br>&nbsp;&nbsp;&nbsp;' Pass the first element of the array intN to CalcMean().<br>&nbsp;&nbsp;&amp;nbspMsgBox &quot;The arithmetic mean is &quot; &amp; CalcMean(intN(0),intTotal)<br>&nbsp;&nbsp;&amp;nbsprst.Close<br>End Function</p>
<p CLASS="CautionStartcas"><span CLASS="CautionHeadingcah"></span></p>
<p CLASS="CautionTextcat"><span CLASS="CautionHeadingcah">Caution&nbsp;&nbsp;&nbsp;</span>You can't pass an entire string array. Each element of a string array must be passed individually, as a null-terminated string using the <span CLASS="ElementNameeln">ByVal</span> keyword. If a DLL procedure tries to access memory beyond the end of the first element in a string array, it may corrupt memory or cause an error. For more information on passing strings, see <a HREF="../chapters/ba12_2.htm#6Strings" OnClick="SyncURL(&quot;chapters/ba12_2.htm&quot;)">&quot;Strings&quot;</a> earlier in this chapter.</p>
<a NAME="6UserDefinedTypes"></a>
<p CLASS="heading6OrgHeading4h4">User-Defined Types</p>
<p CLASS="Textttext">Some DLL procedures take user-defined types as arguments. <span CLASS="NewTermntrm">User-defined types</span> can contain one or more elements of any data type, array, or a previously defined user-defined type.</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>User-defined types are referred to as <span CLASS="NewTermntrm">structures</span> in C and as <span CLASS="NewTermntrm">records</span> in Pascal. DLL documentation often uses the C terminology.</p>
<p CLASS="Textttext">As with an array, you can pass the individual elements of a user-defined type the same way you pass ordinary numeric or string variables.
<p CLASS="Textttext">You can pass an entire user-defined type as a single argument if you pass it by reference. You can't pass user-defined types by value. Microsoft Access passes the address of the first element, and the rest of the elements of a user-defined type are stored in memory following the first element. For example, the Windows GetSystemTime procedure uses the following user-defined type, which you can place in the Declarations section of any module:</p>
<p CLASS="CodeTextct">Type SYSTEMTIME<br>&nbsp;&nbsp;&amp;nbspYear As Integer<br>&nbsp;&nbsp;&amp;nbspMonth As Integer<br>&nbsp;&nbsp;&amp;nbspDayOfWeek As Integer<br>&nbsp;&nbsp;&amp;nbspDay As Integer<br>&nbsp;&nbsp;&amp;nbspHour As Integer<br>&nbsp;&nbsp;&amp;nbspMinute As Integer<br>&nbsp;&nbsp;&amp;nbspSecond As Integer<br>&nbsp;&nbsp;&amp;nbspMilliseconds As Integer<br>End Type</p>
<p CLASS="Textttext">The GetSystemTime procedure accepts the user-defined type SYSTEMTIME and retrieves detailed time information from the system clock. To use the procedure, place the following declaration in the Declarations section of any module:</p>
<p CLASS="CodeTextct">Declare Sub GetSystemTime Lib &quot;kernel32&quot; (lpSystemTime As SYSTEMTIME)</p>
<p CLASS="Textttext">Now you can use the following <span CLASS="ElementNameeln">Sub</span> procedure to call the DLL procedure that retrieves the current time.</p>
<p CLASS="CodeTextct">Sub GetTheTime()<br>&nbsp;&nbsp;&amp;nbspDim usrTime As SYSTEMTIME<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;' Call the procedure to load the SYSTEMTIME structure.<br>&nbsp;&nbsp;&amp;nbspGetSystemTime usrTime <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;' Print the individual time elements to the Immediate pane of the Debug window.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspDebug.Print &quot;Year = &quot;; usrTime.Year<br>&nbsp;&nbsp;&amp;nbspDebug.Print &quot;Month = &quot;; usrTime.Month<br>&nbsp;&nbsp;&amp;nbspDebug.Print &quot;DayOfWeek = &quot;; usrTime.DayOfWeek<br>&nbsp;&nbsp;&amp;nbspDebug.Print &quot;DayOfMonth = &quot;; usrTime.Day<br>&nbsp;&nbsp;&nbsp;' Note that hour is given in Greenwich Mean Time (GMT).<br>&nbsp;&nbsp;&amp;nbspDebug.Print &quot;Hour = &quot;; usrTime.Hour<br>&nbsp;&nbsp;&amp;nbspDebug.Print &quot;Minute = &quot;; usrTime.Minute<br>&nbsp;&nbsp;&amp;nbspDebug.Print &quot;Second = &quot;; usrTime.Second<br>&nbsp;&nbsp;&amp;nbspDebug.Print &quot;Milliseconds = &quot;; usrTime.Milliseconds<br>End Sub</p>
<p CLASS="Textttext">Most procedures that accept user-defined types don't expect the user-defined types to contain string data. However, you can pass a user-defined type that includes fixed-length string elements to a DLL procedure. You can't pass a user-defined type that includes variable-length string elements.</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>When passing a user-defined type that contains binary data to a DLL procedure, be sure to store the binary data in a variable of an array of the <span CLASS="ElementNameeln">Byte</span> data type, instead of in a string variable. Because strings are assumed to contain characters, binary data may not be read properly in external procedures if it's passed as a string variable.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For more information on user-defined data types, see <a HREF="../chapters/ba04_4.htm" OnClick="SyncURL(&quot;chapters/ba04_4.htm&quot;)">&quot;Creating Your Own Data Types&quot;</a> in Chapter 4, &quot;Working with Variables, Data Types, and Constants.&quot;</p>
<a NAME="6NullPointers"></a>
<p CLASS="heading6OrgHeading4h4">Null Pointers</p>
<p CLASS="Textttext">Some DLL procedures occasionally expect to receive a null pointer as an argument. A <span CLASS="NewTermntrm">null pointer </span>is a pointer to nothing; null pointers have a value of zero. If you need to pass a null pointer to a DLL procedure, declare the argument with the <span CLASS="ElementNameeln">As</span> <span CLASS="ElementNameeln">Any</span> keyword and pass the expression <span CLASS="CodeTextEmbeddedcte">ByVal 0&amp;</span>.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also&nbsp;&nbsp;&nbsp;</span>For more information on the<span CLASS="ElementNameeln"> As</span> <span CLASS="ElementNameeln">Any</span> keyword, see <a HREF="../chapters/ba12_2.htm#5PassingFlexibleArgumentTypes" OnClick="SyncURL(&quot;chapters/ba12_2.htm&quot;)">&quot;Passing Flexible Argument Types&quot;</a> earlier in this chapter.</p>
<p CLASS="Textttext">For example, the FindWindow procedure accepts two string arguments, so you may expect to declare it as follows:</p>
<p CLASS="CodeTextct">Declare Function FindWindow Lib &quot;user32&quot; (ByVal lpClassName As String, _<br>&nbsp;&nbsp;&amp;nbspByVal lpWindowName As String) As Long</p>
<p CLASS="Textttext">However, the FindWindow procedure also accepts a null pointer for either or both of its arguments. If you declare it as in the previous example, you can't pass null pointers to it. Passing a zero-length string (&quot;&quot;) doesn't work; this passes a pointer to a null string rather than passing a null pointer.
<p CLASS="Textttext">To pass a null pointer, declare the procedure as follows:</p>
<p CLASS="CodeTextct">Declare Function FindWindow Lib &quot;user32&quot; Alias &quot;FindWindowA&quot; _<br>&nbsp;&nbsp;&nbsp;(lpClassName As Any, lpWindowName As Any) As Long</p>
<p CLASS="Textttext">Although you can still call the procedure and pass it two strings, you can also pass a null pointer as one of the arguments.</p>
<p CLASS="CodeTextct">HWndExcel = FindWindow(ByVal 0&amp;, ByVal &quot;Microsoft Excel&quot;)</p>
<p CLASS="Textttext">Notice the use of the <span CLASS="ElementNameeln">ByVal</span> keyword with both arguments. You must use the <span CLASS="ElementNameeln">ByVal</span> keyword when passing the null pointer to ensure that the routine receives a zero value (a null pointer) instead of a pointer to a zero value.
<p CLASS="Textttext">Also, notice the ampersand character (&amp;) after the zero. This informs Microsoft Access that you are passing a <span CLASS="ElementNameeln">Long</span> integer (32-bit), ensuring that a null pointer of the right size is passed. Pointers in Microsoft Access are always far (32-bit) pointers. You can use this technique to pass a null pointer to any procedure that accepts an argument by reference.</p>
<a NAME="6Handles"></a>
<p CLASS="heading6OrgHeading4h4">Handles</p>
<p CLASS="Textttext">The Windows DLL procedures make extensive use of handles<img SRC="../images/Emdash.gif" BORDER="0" VSPACE="0" HSPACE="0" WIDTH="16" HEIGHT="5">handles to Windows (hWnd), handles to device contexts (hDC), and so on. A <span CLASS="NewTermntrm">handle</span> is a unique long value defined by Windows and used to refer to objects such as forms and reports. When a procedure takes a handle as an argument, always declare it as a <span CLASS="ElementNameeln">ByVal</span> <span CLASS="ElementNameeln">Long</span>. DLL functions that return a handle can be declared as <span CLASS="ElementNameeln">Long</span> functions. Handles are identifier (ID) numbers, not pointers or numeric values. You should never perform mathematical operations on handles.
<p CLASS="Textttext">The <span CLASS="ElementNameeln">hWnd</span> property of forms and reports supplies a valid handle that you can pass to DLL procedures. Like any other property passed to a DLL procedure, it can be passed only by value.</p>
<a NAME="6Properties"></a>
<p CLASS="heading6OrgHeading4h4">Properties</p>
<p CLASS="Textttext">To pass a property directly, you must pass it by value with the <span CLASS="ElementNameeln">ByVal </span>keyword. To pass a property by reference, you must use an intermediate variable. All strings are passed by reference; therefore, to pass a string property to a DLL procedure, you must first assign the property to a string variable and then pass the variable to the procedure.</p>
<a NAME="6ObjectVariables"></a>
<p CLASS="heading6OrgHeading4h4">Object Variables</p>
<p CLASS="Textttext">You can't pass an object variable to a DLL procedure. Object variables are actually complex data structures, and DLL procedures can't make use of them. Likewise, you can't pass any of the system objects (<span CLASS="ElementNameeln">Application</span>, <span CLASS="ElementNameeln">Screen</span>, or <span CLASS="ElementNameeln">Debug</span>) or any DAO objects (<span CLASS="ElementNameeln">Database</span>, <span CLASS="ElementNameeln">Recordset</span>, and so on) to a DLL procedure.</p>
<a NAME="5ConvertingCommonDeclarations"></a>
<p CLASS="heading5OrgHeading3h3">Converting Common Declarations</p>
<p CLASS="Textttext">The procedures in DLLs are most commonly documented using C-language syntax. To call DLL procedures from Microsoft Access, you must translate them into valid <span CLASS="ElementNameeln">Declare</span> statements and call them correctly. The following table lists common C-language declarations and their Visual Basic equivalents.</p>
<!--mstheme--></font><table WIDTH="100%" BORDER="0" CELLPADDING="5" CELLSPACING="0" FRAME="VOID" RULES="THEAD"><thead>
<tr VALIGN="TOP" BGCOLOR="#DDDDDD">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableHeadingth">C-language declaration</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableHeadingth">Visual Basic equivalent</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableHeadingth">Call with</p></font><!--mstheme--></font></td></tr><tbody>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Boolean</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">ByVal </span>B<span CLASS="ElementNameeln"> As Boolean</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any <span CLASS="ElementNameeln">Integer</span> or <span CLASS="ElementNameeln">Variant</span> variable</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Pointer to a string (LPSTR)</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">ByVal</span> S <span CLASS="ElementNameeln">As</span> <span CLASS="ElementNameeln">String</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any <span CLASS="ElementNameeln">String</span> or <span CLASS="ElementNameeln">Variant</span> variable</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Pointer to an integer (LPINT)</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">I <span CLASS="ElementNameeln">As</span> <span CLASS="ElementNameeln">Integer</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any <span CLASS="ElementNameeln">Integer</span> or <span CLASS="ElementNameeln">Variant</span> variable</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Pointer to a long integer (LPDWORD)</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">L <span CLASS="ElementNameeln">As</span> <span CLASS="ElementNameeln">Long</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any <span CLASS="ElementNameeln">Long</span> or <span CLASS="ElementNameeln">Variant</span> variable</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Pointer to a structure <br>(for example, LPRECT)</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">S <span CLASS="ElementNameeln">As</span> RECT</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any variable of that user-defined type</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Integer (INT, UINT, WORD, BOOL)</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">ByVal</span> I <span CLASS="ElementNameeln">As</span> <span CLASS="ElementNameeln">Integer</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any <span CLASS="ElementNameeln">Integer</span> or <span CLASS="ElementNameeln">Variant</span> variable</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Handle (32-bit)</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">ByVal </span>H<span CLASS="ElementNameeln"> As Long</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any <span CLASS="ElementNameeln">Long</span> or <span CLASS="ElementNameeln">Variant</span> variable</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Long (DWORD, LONG)</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">ByVal</span> L <span CLASS="ElementNameeln">As</span> <span CLASS="ElementNameeln">Long</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any <span CLASS="ElementNameeln">Long</span> or <span CLASS="ElementNameeln">Variant</span> variable</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Pointer to an array of integers</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">I <span CLASS="ElementNameeln">As Integer</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">The first element of the array, such as I(0)</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Pointer to a void (void *)</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">V<span CLASS="ElementNameeln"> As</span> <span CLASS="ElementNameeln">Any</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any variable (use <span CLASS="ElementNameeln">ByVal</span> when passing a string)</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Void (function return value)</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">Sub</span> procedure</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Not applicable</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">NULL</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">As Any</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">ByVal</span> 0<span CLASS="ElementNameeln">&amp;</span></p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Char</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">ByVal </span>Ch<span CLASS="ElementNameeln"> As Byte</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any <span CLASS="ElementNameeln">Byte</span> or<span CLASS="ElementNameeln"> Variant</span> variable</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Pointer to a char</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Ch <span CLASS="ElementNameeln">As Byte</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Any <span CLASS="ElementNameeln">Byte </span>or <span CLASS="ElementNameeln">Variant</span> variable</p></font><!--mstheme--></font></td></tr>
</table><!--mstheme--><font face="book antiqua, times new roman, times">
<p><!--DocFooterStart-->
<p><span CLASS="copyright"><a HREF="cpyright.htm">© 1996 Microsoft Corporation. All rights reserved.</a></span>
<p><!--DocFooterEnd-->
<a HREF="ba13_1.htm" OnClick="SyncURL(&quot;chapters/ba13_1.htm&quot;)"><img SRC="..\images\nextpage.gif" ALT="Next Page" ALIGN="RIGHT" BORDER="0"></a><!--mstheme--></font></body></html>
