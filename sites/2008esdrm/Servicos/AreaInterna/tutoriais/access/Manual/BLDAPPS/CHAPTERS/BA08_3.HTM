<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html><head><title>Using On Error Statements</title>
<link REL="STYLESHEET" HREF="naetugp.css" TYPE="text/css">
<script Language="VBScript">
Dim look
Sub SyncURL(look)
if right(top.frames(0).frames(1).location.href, 10)="toc_tc.htm" then
top.frames(0).frames(1).TreeCtl1.SyncToURL(look)
end if
End Sub
</script>
<meta name="Microsoft Theme" content="expeditn 011, default"></head>
<!--DocHeaderStart-->
<body background="../../../../_themes/expeditn/exptextb.jpg" bgcolor="#FFFFFF" text="#000000" link="#993300" vlink="#666600" alink="#CC3300"><!--mstheme--><font face="book antiqua, times new roman, times"><a HREF="ba08_2.htm" OnClick="SyncURL(&quot;chapters/ba08_2.htm&quot;)"><img SRC="..\images\prevpage.gif" ALT="Previous Page" ALIGN="RIGHT" BORDER="0"></a>
<!--DocHeaderEnd-->
<!-- This is a PANDA Generated HTML file. The source is a WinWord Document. -->
<a NAME="3UsingOnErrorStatements"></a>
<p CLASS="heading3OrgHeading1h1">Using On Error Statements</p>
<p CLASS="Textttext">You can handle Visual Basic run-time errors by adding <span CLASS="ElementNameeln">On Error</span> statements and error-handling code to your procedures. For example, the event procedures created by Microsoft Access wizards include <span CLASS="ElementNameeln">On Error</span> statements and error-handling code. The following Click event procedure created by a control wizard shows how many of the procedures created by wizards handle errors.</p>
<p CLASS="CodeTextct">Private Sub Button1_Click()<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&amp;nbspDim strDocName As String<br>&nbsp;&nbsp;&amp;nbspOn Error GoTo Err_Button1_Click<br>&nbsp;&nbsp;&amp;nbspstrDocName = &quot;ProductsPopUp&quot;<br>&nbsp;&nbsp;&amp;nbspDoCmd.OpenForm strDocName<br>Exit_Button1_Click:<br>&nbsp;&nbsp;&amp;nbspExit Sub<br>Err_Button1_Click:<br>&nbsp;&nbsp;&amp;nbspMsgBox Err.Description<br>&nbsp;&nbsp;&amp;nbspResume Exit_Button1_Click<br>End Sub</p>
<p CLASS="Textttext">In this code, the <span CLASS="ElementNameeln">On Error</span> statement turns on error handling. If an error occurs, Visual Basic <span CLASS="NewTermntrm">branches</span> (passes program control) to the Err_Button1_Click line label, which marks the beginning of the error-handling code. It then runs the <span CLASS="ElementNameeln">MsgBox</span> statement, displaying the error's message string. Visual Basic then runs the <span CLASS="ElementNameeln">Resume</span> statement to exit the error-handling code, branching to the Exit_Button1_Click line label. Finally, Visual Basic runs the <span CLASS="ElementNameeln">Exit Sub</span> statement to exit the Button1_Click procedure.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also</span>&nbsp;&nbsp;&amp;nbspFor information on line labels, search the Help index for &quot;GoTo statement.&quot;</p>
<p CLASS="Textttext">If no error occurs, Visual Basic runs each line of code until it reaches the <span CLASS="ElementNameeln">Exit Sub</span> statement and then exits the procedure. It doesn't run the Err_Button1_Click error-handling code that follows.
<p CLASS="Textttext">If your application doesn't handle Visual Basic run-time errors, users may be surprised if a run-time error suddenly halts the application. It's especially important to handle Visual Basic errors if you're creating a run-time version of your application. A run-time application shuts down if an untrapped error occurs.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also</span>&nbsp;&nbsp;&amp;nbspFor information on creating a run-time version of your application, see Chapter 15, <a HREF="../chapters/ba15_1.htm" OnClick="SyncURL(&quot;chapters/ba15_1.htm&quot;)">&quot;Delivering Your Application.&quot;</a></p>
<p CLASS="Textttext">For example, the following procedure doesn't contain error-handling code. It returns <span CLASS="ElementNameeln">True</span> (- 1) if the specified file exists and <span CLASS="ElementNameeln">False</span> (0) if it doesn't exist.</p>
<p CLASS="CodeTextct">Function FileExists (ByVal strFileName As String) As Boolean<br>&nbsp;&nbsp;&amp;nbspFileExists = (Dir(strFileName) &lt;&gt; &quot;&quot;)<br>End Function</p>
<p CLASS="Textttext">The <span CLASS="ElementNameeln">Dir</span> function returns the first file matching the specified file name, and returns a zero-length string (&quot;&quot;) if no matching file is found. The code appears to cover either of the possible outcomes of the <span CLASS="ElementNameeln">Dir</span> call. However, if the drive letter specified in the argument isn't a valid drive, the run-time error message &quot;Device unavailable&quot; is displayed. If the specified drive is a floppy disk drive, this function works correctly only if a disk is in the drive and the drive door is closed. If not, the run-time error &quot;Disk not ready&quot; occurs. In both cases, Microsoft Access displays the error message and halts execution of the code.
<p CLASS="Textttext">To avoid this situation, you can use an <span CLASS="ElementNameeln">On Error</span> statement to respond to Visual Basic errors and take corrective action. For example, device problems such as an invalid drive or an empty floppy disk drive can be handled by the following code:</p>
<p CLASS="CodeTextct">Function FileExists (ByVal strFileName As String) As Boolean<br>&nbsp;&nbsp;&amp;nbspDim strMsg As String<br>&nbsp;&nbsp;&amp;nbspOn Error GoTo CheckError&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Turn on error handling.<br>&nbsp;&nbsp;&amp;nbspFileExists = (Dir(strFileName) &lt;&gt; &quot;&quot;)&nbsp;&nbsp;&nbsp;' Use Dir function to see <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' if file exists.<br>&nbsp;&nbsp;&amp;nbspExit Function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Avoid running error-handling<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' code if no error occurs.<br>CheckError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Run following code <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' if error occurs.<br>&nbsp;&nbsp;&nbsp;' Declare constants to represent Visual Basic error codes.<br>&nbsp;&nbsp;&amp;nbspConst conErrDiskNotReady = 71, conErrDeviceUnavailable = 68<br>&nbsp;&nbsp;&nbsp;' vbExclamation, vbOK, vbCancel, vbCritical, and vbOKCancel are<br>&nbsp;&nbsp;&nbsp;' intrinsic constants that don't need to be declared.<br>&nbsp;&nbsp;&amp;nbspIf (Err.Number = conErrDiskNotReady) Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Display message box with an exclamation point icon and with <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' OK and Cancel buttons.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspstrMsg = &quot;Put a floppy disk in the drive and close the drive door.&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspIf MsgBox(strMsg, vbExclamation + vbOKCancel) = vbOK Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspResume<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspElse<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspResume Next<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspEnd If<br>&nbsp;&nbsp;&amp;nbspElseIf Err.Number = conErrDeviceUnavailable Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspstrMsg = &quot;This drive or path does not exist: &quot; &amp; strfilename<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspMsgBox strMsg, vbExclamation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspResume Next<br>&nbsp;&nbsp;&amp;nbspElse<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspstrMsg = &quot;Error number &quot; &amp; Str(Err.Number) &amp; &quot; occurred: &quot; &amp; _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspErr.Description<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Display message box with stop sign icon and OK button.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspMsgBox strMsg, vbCritical<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspStop<br>&nbsp;&nbsp;&amp;nbspEnd If<br>&nbsp;&nbsp;&amp;nbspResume<br>End Function</p>
<p CLASS="Textttext">This code uses properties of the <span CLASS="ElementNameeln">Err </span>object to return the error code number and the message string associated with the run-time error that occurred.
<p CLASS="Textttext">When Visual Basic generates the error &quot;Disk not ready,&quot; the FileExists function displays a message telling the user to click one of two buttons, OK or Cancel. If the user clicks OK, the <span CLASS="ElementNameeln">Resume</span> statement returns program control to the statement at which the error occurred and attempts to run that statement again. This statement succeeds if the user has corrected the problem; otherwise, the program returns to the error-handling code.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also</span>&nbsp;&nbsp;&amp;nbspFor more information on the methods and properties of the <span CLASS="ElementNameeln">Err</span> object, search the Help index for &quot;Err object.&quot;</p>
<p CLASS="Textttext">If the user clicks Cancel, the <span CLASS="ElementNameeln">Resume Next</span> statement returns program control to the statement following the one at which the error occurred, in this case, the <span CLASS="ElementNameeln">Exit Function</span> statement.
<p CLASS="Textttext">If the &quot;Device unavailable&quot; error occurs, Visual Basic displays a message describing the problem. The <span CLASS="ElementNameeln">Resume Next</span> statement then returns program control to the statement following the one at which the error occurred.
<p CLASS="Textttext">If an unanticipated error occurs, Visual Basic displays an alternative message and halts the code at the <span CLASS="ElementNameeln">Stop</span> statement.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also</span>&nbsp;&nbsp;&amp;nbspFor more information on using the <span CLASS="ElementNameeln">Stop</span> statement for error handling, see <a HREF="../chapters/ba08_5.htm" OnClick="SyncURL(&quot;chapters/ba08_5.htm&quot;)">&quot;Guidelines for Complex Error Handling&quot;</a> later in this chapter.</p>
<p CLASS="Textttext">The error-handling code in the preceding example involves three steps:</p>
<p CLASS="ListSequentialItem1ls">1.&nbsp;&amp;nbspTurn on error handling, and set (<span CLASS="NewTermntrm">enable)</span> an error trap by telling the application where to branch (which error-handling routine to run) when an error occurs.</p>
<p CLASS="ListText1lt1">The <span CLASS="ElementNameeln">On Error </span>statement in the FileExists function turns on error handling and directs the application to the CheckError line label.</p>
<p CLASS="ListSequentialItem1ls">2.&nbsp;&amp;nbspWrite error-handling code that responds to all errors you can anticipate. If program control actually branches to the error-handling code at some point, the trap is then said to be <span CLASS="NewTermntrm">active</span>.</p>
<p CLASS="ListText1lt1">The CheckError code handles the error by using an <span CLASS="ElementNameeln">If...Then...Else</span> statement that checks the value returned by the <span CLASS="ElementNameeln">Number</span> property of the <span CLASS="ElementNameeln">Err</span> object. The <span CLASS="ElementNameeln">Number</span> property of the <span CLASS="ElementNameeln">Err</span> object returns an error code number corresponding to the error message that Visual Basic generates. In the example, if the &quot;Disk not ready&quot; error is generated, a message prompts the user to close the drive door. A different message is displayed if the &quot;Device unavailable&quot; error occurs.
<p CLASS="ListText1lt1">Your code should also determine what action to take if an unanticipated error occurs. In the previous FileExists function, if any error other than &quot;Disk not ready&quot; or &quot;Device unavailable&quot; occurs, a general message is displayed and the program stops.</p>
<p CLASS="ListSequentialItem1ls">3.&nbsp;&amp;nbspExit the error-handling code.</p>
<p CLASS="ListText1lt1">In the case of the &quot;Disk not ready&quot; error, the <span CLASS="ElementNameeln">Resume</span> statement passes program control back to the statement at which the error occurred. Visual Basic then tries to run that statement again. If the situation hasn't changed, then the same error occurs again, and execution branches back to the error-handling code.
<p CLASS="ListText1lt1">In the case of the &quot;Device unavailable&quot; error, the <span CLASS="ElementNameeln">Resume Next</span> statement passes program control to the statement following the one at which the error occurred.
<p CLASS="ListText1lt1"></p>
<p CLASS="Textttext">The following sections describe in detail how to perform these steps. Refer to the FileExists function in this section as you read.</p>
<a NAME="4SettingtheErrorTrap"></a>
<p CLASS="heading4OrgHeading2h2">Setting the Error Trap</p>
<p CLASS="Textttext">The first step in writing error-handling code is creating an <span CLASS="ElementNameeln">On Error </span>statement, which specifies the next line of code to run if an error occurs. Use the syntax <span CLASS="ElementNameeln">On Error GoTo </span><span CLASS="NewTermntrm">line</span>, where <span CLASS="NewTermntrm">line</span> indicates the line label identifying the error-handling code. Running the <span CLASS="ElementNameeln">On Error </span>statement turns on error handling and enables an error trap. The error trap remains enabled while the procedure containing it is active; that is, until an <span CLASS="ElementNameeln">Exit Sub</span>, <span CLASS="ElementNameeln">Exit Function</span>, <span CLASS="ElementNameeln">End Sub</span>, or <span CLASS="ElementNameeln">End Function</span> statement is run for that procedure. You can disable error handling in the current procedure by using another form of the <span CLASS="ElementNameeln">On Error </span>statement, <span CLASS="ElementNameeln">On Error GoTo 0</span>.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also</span>&nbsp;&nbsp;&amp;nbspFor more information on disabling error handling, see <a HREF="../chapters/ba08_8.htm" OnClick="SyncURL(&quot;chapters/ba08_8.htm&quot;)">&quot;Turning Off Error Handling&quot;</a> later in this chapter.</p>
<a NAME="4WritingErrorHandlingCode"></a>
<p CLASS="heading4OrgHeading2h2">Writing Error-Handling Code</p>
<p CLASS="Textttext">Begin the error-handling code with the line label specified in the <span CLASS="ElementNameeln">On Error</span> statement. In the FileExists function, the line label is CheckError. The colon is part of the label, although it isn't used in the <span CLASS="ElementNameeln">On Error GoTo </span><span CLASS="NewTermntrm">line</span><span CLASS="CrossRefHeadingcrh"> </span>statement.
<p CLASS="Textttext">You'll usually include error-handling code at the end of a procedure, before the <span CLASS="ElementNameeln">End Function</span> or <span CLASS="ElementNameeln">End Sub</span> statement. Enter an <span CLASS="ElementNameeln">Exit Function</span>, <span CLASS="ElementNameeln">Exit Sub</span>, or<span CLASS="ElementNameeln"> Exit Property</span> statement at the end of the main procedure code, but immediately preceding the error handler's line label. This prevents Visual Basic from running the error-handling code at the conclusion of the main-procedure code if no error occurs.
<p CLASS="Textttext">The <span CLASS="ElementNameeln">Number</span> property of the <span CLASS="ElementNameeln">Err </span>object returns an error code number representing the most recent run-time error. By using the <span CLASS="ElementNameeln">Number</span> property of the <span CLASS="ElementNameeln">Err</span> object in combination with the <span CLASS="ElementNameeln">Select Case </span>or <span CLASS="ElementNameeln">If...Then...Else</span> statement, you can take specific action for any error that occurs.</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>The string returned by the <span CLASS="ElementNameeln">Description </span>property of the <span CLASS="ElementNameeln">Err</span> object always explains the error associated with the current error code number. However, the exact wording of the message may vary among different versions of Microsoft Access. Therefore, use the <span CLASS="ElementNameeln">Number</span> property rather than the <span CLASS="ElementNameeln">Description</span> property to identify the specific error that occurred.</p>
<p CLASS="Textttext">When designing your error-handling routine, include code that tells the user what the problem is and how to proceed. Also, if the application can't continue after an error is encountered, it's a good idea to close open objects, remote connections, and database files when you exit the application.</p>
<a NAME="4ExitingErrorHandlingCode"></a>
<p CLASS="heading4OrgHeading2h2">Exiting Error-Handling Code</p>
<p CLASS="Textttext">The preceding FileExists function uses the <span CLASS="ElementNameeln">Resume </span>statement within the error-handling code to rerun the statement that caused the error, and uses the <span CLASS="ElementNameeln">Resume Next</span> statement to resume execution at the statement following the one at which the error occurred. Depending on the circumstances, there are other ways to exit error-handling code; regardless of which way you exit, you should always tell the error handler what to do when its execution is complete. To exit error-handling code, use any of the statements shown in the following table.</p>
<!--mstheme--></font><table WIDTH="100%" BORDER="0" CELLPADDING="5" CELLSPACING="0" FRAME="VOID" RULES="THEAD"><thead>
<tr VALIGN="TOP" BGCOLOR="#DDDDDD">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableHeadingth">Statement</p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableHeadingth">Description</p></font><!--mstheme--></font></td></tr><tbody>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">Resume</span> </p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Resumes program execution starting with the statement that caused the error.</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">Resume Next</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Resumes program execution at the statement immediately following the one that caused the error.</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">Resume</span> <span CLASS="NewTermntrm">line</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Resumes program execution at the label specified by <span CLASS="NewTermntrm">line</span>, where <span CLASS="NewTermntrm">line</span> is a line label that must be in the same procedure as the error handler.</p></font><!--mstheme--></font></td></tr>
<tr VALIGN="TOP">
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt"><span CLASS="ElementNameeln">Err.Raise Number:= </span><span CLASS="NewTermntrm">number</span></p></font><!--mstheme--></font></td>
<td><!--mstheme--><font face="book antiqua, times new roman, times"><font FACE="Arial" SIZE="2">
<p CLASS="TableTexttt">Triggers the most recent run-time error again. When this statement is run within error-handling code, Visual Basic searches backward through the calls list for other error-handling code. The <span CLASS="NewTermntrm">calls list</span> is the chain of procedures that lead to the current point of execution. For more information, see <a HREF="../chapters/ba08_4.htm" OnClick="SyncURL(&quot;chapters/ba08_4.htm&quot;)">&quot;Unanticipated Errors&quot;</a> later in this chapter.</p></font><!--mstheme--></font></td></tr>
</table><!--mstheme--><font face="book antiqua, times new roman, times">&nbsp;&nbsp;&nbsp;<a NAME="5TheResumeandResumeNextStatements"></a>
<p CLASS="heading5OrgHeading3h3">The Resume and Resume Next Statements</p>
<p CLASS="Textttext">You can use the <span CLASS="ElementNameeln">Resume</span> and <span CLASS="ElementNameeln">Resume Next</span> statements to perform similar functions. The <span CLASS="ElementNameeln">Resume</span> statement returns program control to the statement that caused the error. You use it to rerun the statement after correcting the error. The <span CLASS="ElementNameeln">Resume Next</span> statement returns program control to the statement immediately following the one that caused the error. The difference between <span CLASS="ElementNameeln">Resume</span> and <span CLASS="ElementNameeln">Resume Next</span> is shown in the following illustration.</p>
<p CLASS="Arta"><img SRC="..\images\abac0801.jpg"></p>
<p CLASS="Textttext">Generally, you use the <span CLASS="ElementNameeln">Resume</span> statement whenever the user must make a correction. Use the <span CLASS="ElementNameeln">Resume Next</span> statement whenever a correction by the user isn't required, and you want to continue program execution without attempting to rerun the statement that caused the error. You can also use the <span CLASS="ElementNameeln">Resume Next</span> statement<span CLASS="CrossRefHeadingcrh"> </span>if you anticipate an error in a loop, and you want to start the loop operation again if an error occurs. With the <span CLASS="ElementNameeln">Resume Next</span> statement, you can write error-handling code so that the existence of a run-time error isn't revealed to the user. 
<p CLASS="Textttext">For example, the following Divide function uses error handling to perform division on its numeric arguments without revealing errors that have occurred. There are several errors that can occur in division. If the numerator is not zero, but the denominator is zero, Visual Basic generates the &quot;Division by zero&quot; error; if both numerator and denominator are zero in floating-point division, it generates the &quot;Overflow&quot; error; or if either the numerator or the denominator is a nonnumeric value (or can't be considered a numeric value), Visual Basic displays an appropriate error message. In all three cases, the Divide function traps these errors and returns the <span CLASS="ElementNameeln">Null </span>value.</p>
<p CLASS="CodeTextct">Function Divide (Numerator, Denominator) As Variant<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&amp;nbspConst conErrDivo = 11, conErrOverflow = 6, conErrIllFunc = 5<br>&nbsp;&nbsp;&amp;nbspOn Error GoTo MathHandler <br>&nbsp;&nbsp;&amp;nbspDivide = Numerator / Denominator<br>&nbsp;&nbsp;&amp;nbspExit Function<br>MathHandler:<br>&nbsp;&nbsp;&nbsp;' If error was Division by zero, Overflow, or <br>&nbsp;&nbsp;&nbsp;' Illegal function call, return Null.<br>&nbsp;&nbsp;&amp;nbspIf Err.Number = conErrDivo Or Err.Number = conErrOverflow Or _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspErr.Number = conErrIllFunc Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspDivide = Null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&amp;nbspElse<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspMsgBox &quot;Unanticipated error &quot; &amp; Err.Number &amp; &quot;: &quot; &amp; _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspError.Description, vbExclamation<br>&nbsp;&nbsp;&amp;nbspEnd If&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;' In all cases, Resume Next continues execution at the <br>&nbsp;&nbsp;&nbsp;' Exit Function statement.<br>&nbsp;&nbsp;&amp;nbspResume Next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>End Function</p>
<a NAME="5TheResume"></a>
<p CLASS="heading5OrgHeading3h3">The Resume <span CLASS="NewTermntrm">line </span>Statement</p>
<p CLASS="Textttext">Alternatively, you can use the syntax <span CLASS="ElementNameeln">Resume </span><span CLASS="NewTermntrm">line</span>, which returns control to a specified line label. The following example illustrates the use of the <span CLASS="ElementNameeln">Resume</span> <span CLASS="NewTermntrm">line</span> statement. A variation on the preceding FileExists function, the following VerifyFile function enables the user to enter a file specification that the function returns if the file exists.</p>
<p CLASS="CodeTextct">Function VerifyFile () As Variant<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&amp;nbspConst conErrBadFileName = 52, conErrDriveDoorOpen = 71<br>&nbsp;&nbsp;&amp;nbspConst conErrDeviceUnavailable = 68, conErrInvalidFileName = 64<br>&nbsp;&nbsp;&amp;nbspDim strPrompt As String, strMsg As String, strFileSpec As String<br>&nbsp;&nbsp;&amp;nbspOn Error GoTo Handler<br>&nbsp;&nbsp;&amp;nbspstrPrompt = &quot;Enter file specification to check:&quot;<br>StartHere:<br>&nbsp;&nbsp;&amp;nbspstrFileSpec = &quot;*.*&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Start with a default spec.<br>&nbsp;&nbsp;&amp;nbspstrMsg = strMsg &amp; vbCrLf &amp; strPrompt<br>&nbsp;&nbsp;&nbsp;' Let the user modify the default.<br>&nbsp;&nbsp;&amp;nbspstrFileSpec = InputBox(strMsg, &quot;File Search&quot;, strFileSpec, 100, 100)<br>&nbsp;&nbsp;&nbsp;' Exit if the user enters nothing.&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&amp;nbspIf strFileSpec = &quot;&quot; Then Exit Function&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&amp;nbspVerifyFile = Dir(strFileSpec)<br>&nbsp;&nbsp;&amp;nbspExit Function<br>Handler:<br>&nbsp;&nbsp;&amp;nbspSelect Case Err.Number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Analyze error code, then load message.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspCase conErrInvalidFileName, conErrBadFileName<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspstrMsg = &quot;Your file specification is invalid. Try another.&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspCase conErrDriveDoorOpen<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspstrMsg = &quot;Close the disk drive door and try again.&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspCase conErrDeviceUnavailable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspstrMsg = &quot;The drive you specified was not found. Try again.&quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspCase Else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspDim intErrNum As Integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspintErrNum = Err.Number<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspErr.Clear&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Clear the Err object.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;nbspErr.Raise Number:=intErrNum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' Regenerate the error.<br>&nbsp;&nbsp;&amp;nbspEnd Select<br>&nbsp;&nbsp;&nbsp;' This jumps back to the StartHere label so the user can <br>&nbsp;&nbsp;&nbsp;' try another file name.<br>&nbsp;&nbsp;&amp;nbspResume StartHere&nbsp;&nbsp;&nbsp;<br>End Function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p CLASS="Textttext">If a file matching the specification is found, the function returns the file name. If no matching file is found, the function returns a zero-length string (&quot;&quot;). If one of the anticipated errors occurs, a message appropriate to the error is assigned to <span CLASS="CodeTextEmbeddedcte">Msg</span> and execution branches to the StartHere line label. This gives the user another chance to enter a valid path and file specification.
<p CLASS="Textttext">Use the <span CLASS="ElementNameeln">Resume </span><span CLASS="NewTermntrm">line</span> statement when you want to resume execution at a place other than the statement that caused the error, or the line immediately after the statement that caused the error. The <span CLASS="ElementNameeln">Resume </span><span CLASS="NewTermntrm">line</span> statement can be especially useful if you want to exit the error-handling code and branch to a point just before an <span CLASS="ElementNameeln">Exit</span> statement in a <span CLASS="ElementNameeln">Function</span> or <span CLASS="ElementNameeln">Sub</span> procedure.</p>
<p CLASS="NoteTextnt"><span CLASS="NoteHeadingnh">Note&nbsp;&nbsp;&nbsp;</span>Although branching to a line label can be useful in some circumstances, jumps to labels are often considered throwbacks to a less structured style of programming. Too many <span CLASS="ElementNameeln">Resume</span> <span CLASS="NewTermntrm">line</span> statements can make code difficult to understand and debug.</p>
<a NAME="5TheRaiseMethod"></a>
<p CLASS="heading5OrgHeading3h3">The Raise Method</p>
<p CLASS="Textttext">The previous VerifyFile function also illustrates how to use the <span CLASS="ElementNameeln">Raise</span> method of the <span CLASS="ElementNameeln">Err</span> object to regenerate an unanticipated Visual Basic error within the error-handling routine itself. This causes Visual Basic to search backward through the calls list (if there is one) for error-handling code.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also</span>&nbsp;&nbsp;&amp;nbspFor more information on this process, see the following section, <a HREF="../chapters/ba08_4.htm" OnClick="SyncURL(&quot;chapters/ba08_4.htm&quot;)">&quot;Unanticipated Errors.&quot;</a></p>
<p CLASS="Textttext">If you haven't included appropriate code to handle the error that has occurred, Visual Basic halts execution and displays an error message. The <span CLASS="ElementNameeln">Raise</span> method only returns descriptive strings for Visual Basic errors. If you use the <span CLASS="ElementNameeln">Raise</span> method to regenerate a Microsoft Access error, then you can use the <span CLASS="ElementNameeln">AccessError</span> method of the <span CLASS="ElementNameeln">Application</span> object to return a descriptive string for the error.</p>
<p CLASS="CrossRefTextcrt"><span CLASS="CrossRefHeadingcrh">See Also</span>&nbsp;&nbsp;&amp;nbspFor more information on the <span CLASS="ElementNameeln">AccessError</span> method, search the Help index for &quot;AccessError method.&quot;</p>
<p><!--DocFooterStart-->
<p><span CLASS="copyright"><a HREF="cpyright.htm">© 1996 Microsoft Corporation. All rights reserved.</a></span>
<p><!--DocFooterEnd-->
<a HREF="ba08_4.htm" OnClick="SyncURL(&quot;chapters/ba08_4.htm&quot;)"><img SRC="..\images\nextpage.gif" ALT="Next Page" ALIGN="RIGHT" BORDER="0"></a><!--mstheme--></font></body></html>
